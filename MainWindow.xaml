<Window x:Name="SystemVerilog" x:Class="SystemVerilogDV.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:SystemVerilogDV"
        mc:Ignorable="d"
        Title="System Verilog DV" Height="830.5" Width="1249.5" MaxWidth="1250" MaxHeight="990">
    <Window.Background>
        <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">
            <GradientStop Color="Black" Offset="0"/>
            <GradientStop Color="{DynamicResource {x:Static SystemColors.GradientInactiveCaptionColorKey}}" Offset="1"/>
        </LinearGradientBrush>
    </Window.Background>
    <Grid Margin="0,0,66,8">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="439*"/>
            <ColumnDefinition Width="32*"/>
            <ColumnDefinition Width="725*"/>
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="33*"/>
            <RowDefinition Height="670*"/>
            <RowDefinition Height="88*"/>
            <RowDefinition Height="0*"/>
        </Grid.RowDefinitions>
        <Label Content="Reference: Formal Verification: an essential toolkit for modern VLSI design Erik Seligman, Tom Schubert, Kiran Kumar,2015" HorizontalAlignment="Left" Margin="6,66,0,0" RenderTransformOrigin="5.184,1.231" Width="574" Height="22" VerticalAlignment="Top" Grid.Row="2" FontSize="10" Grid.ColumnSpan="3"/>
        <Label Content="Reference: SVA: power of assertions in SystemVerilog, Eduard Cerny, 2014" HorizontalAlignment="Left" Margin="8,35,0,0" VerticalAlignment="Top" Width="348" RenderTransformOrigin="1.611,1.038" Height="25" Grid.Row="2" FontSize="10"/>
        <RichTextBox HorizontalAlignment="Left" Height="24" Margin="4,5,0,0" VerticalAlignment="Top" Width="1099" Grid.ColumnSpan="3">
            <FlowDocument>
                <Paragraph>
                    <Run FontWeight="Bold" Text="FORMAL VERIFICATION: "/>
                    <Run Text="FV is the use of tools that mathematically analyze the space of possible behaviors of the design rather than computing results (writing individual test benches) for  specific values"/>
                    <Run FontWeight="Bold" Text="."/>
                </Paragraph>
                <Paragraph>
                    <Run FontWeight="Bold" Text=""/>
                </Paragraph>
                <Paragraph>
                    <Run FontWeight="Bold"/>
                </Paragraph>
            </FlowDocument>
        </RichTextBox>
        <Label Content="Reference: SystemVerilog assertions and function coverage: guide to language,methodology and applications, Ashok Mehta, 2016" HorizontalAlignment="Left" Margin="6,51,0,0" VerticalAlignment="Top" Width="588" RenderTransformOrigin="1.611,1.038" Height="23" Grid.Row="2" FontSize="10" Grid.ColumnSpan="3"/>
        <RichTextBox HorizontalAlignment="Left" Height="104" Margin="7,2,0,0" VerticalAlignment="Top" Width="607" Grid.ColumnSpan="3" TextChanged="RichTextBox_TextChanged" Grid.Row="1">
            <FlowDocument>
                <Paragraph>
                    <Run FontWeight="Bold" Text="Formal Verification: "/>
                    <Run Text="Techniques for preparing designs for verification include the following:  * "/>
                    <Run FontWeight="Bold" FontStyle="Italic" Text="State Matching"/>
                    <Run Text=", simplify the verification problem by understanding the schematics of the RTL design * "/>
                    <Run FontWeight="Bold" FontStyle="Italic" Text="Bounded proofs "/>
                    <Run Text=": Guaranteeing accurate coverage up to a specific limit * Proof Decomposition: Improve our FV capacity * "/>
                    <Run FontWeight="Bold" FontStyle="Italic" Text="Targeted Verification"/>
                    <Run Text=", * "/>
                    <Run FontStyle="Italic" Text="Size reductions"/>
                    <Run Text=" : analyze the design to catch the vast majority of bugs * "/>
                    <Run FontStyle="Italic" Text="Case  Splitting"/>
                    <Run Text=": Targeted verification on a case by case basis * "/>
                    <Run FontWeight="Bold" FontStyle="Italic" Text="Design abstractions"/>
                    <Run FontStyle="Italic" Text=": "/>
                    <Run Text="Validate the output     "/>
                    <Run FontWeight="Bold" FontStyle="Italic" Text="Data abstractions"/>
                    <Run FontStyle="Italic" Text=":"/>
                    <Run Text=" Analyze possible subsets of data.  "/>
                </Paragraph>
            </FlowDocument>
        </RichTextBox>
        <RichTextBox HorizontalAlignment="Left" Height="761" Margin="156,0,-58,-3" VerticalAlignment="Top" Width="615" TextChanged="RichTextBox_TextChanged_1" Grid.Column="2" Grid.Row="1" Grid.RowSpan="3">
            <FlowDocument>
                <Paragraph>
                    <Run FontWeight="Bold" Text="System Verilog Assertions: "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="Industry standard over the last decade for specifying RTL assertions. The most common way to do this is through properties specified in assertions, there are numerous specification methods in the industry and academia such as Property Specification Language (PSL) and Open Verification Library (OVL). Basic assertion concepts:  An "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Assertion "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="is a statement about the design that you expect to be always true. An "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Assumption "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="specifies the external conditions that are guaranteed to be true. "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Cover point:  "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="Testing an interesting condition, the script saves information to a database when a cover point is accessed. The user can examine the total coverage after running all the simulation tests in their test suite.  "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Immediate assertion: "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="Accessed during code evaluation, they have no concept of clocks or reset and hence are incapable of verifying behavior that spans over time. Immediate assertions placed in a clocked procedural statement is a concurrent assertion.  Also known as non-temporal domain assertions. "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Concurrent assertion: "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="Always utilize concurrent assertions instead of immediate assertions, using assertions that are relative to known clocks is a feature that is directly supported by concurrent assertions. Immediate assertions might report on incorrect temporary values if not stated relative to a clock Concurrent assertions are also called temporal domain assertions and are edge sensitive"/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text=". Benefits include"/>
                    <Run Text=" "/>
                    <Run Text=":  SVA language supports multi-clock domain crossing (CDC) logic,  Assertions are readable, Reusable for future designs, Assertions are always On, acceleration / emulation with assertions, global severity levels, formal verification depends on assertions, one language , multiple  usage.  "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Types of assertions include: "/>
                    <Run Text=" "/>
                    <Run Text=" RTL assertions (design intent), Module interface assertions (design interface intent), Chip functionality Assertions (chip/ SoC functional intent), Chip interface assertions (chip interface intent) , performance implication assertions (performance intent)."/>
                </Paragraph>
                <Paragraph>
                    <Run FontWeight="Bold" Text="Formal Property Verification:  "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text=" "/>
                    <Run Text="Is the process of verifying properties usually expressed as assertions or cover points on an RTL model. However it is fundamentally different from design verification simulations. The inputs to the process includes : * An RTL model, * A set of properties to prove: assertions &amp; cover points * A set of constraints: assumptions, plus clock and reset definitions.  Unlike simulations it does not check a specific signal value, all possible achievable values under the current constraints are checked at once:  Hence the output of the process is a proven property list (proven assertions and unreachable cover points - i.e beyond the scope of the current verification environment) , bounded proof ( for each disproved assertion or reachable cover point a waveform showing a case of failure / reach ability and a list of bounded or inconclusive proofs: asserts and covers that were not definitely proven or disproven. For all modern FPV tools, the RTL models used in FPV must be synthesizable however popular simulation based validation methodologies like Open Verification Methodology (OVM) and Universal Verification Methodology (UVM) can be separated from the synthesizable models by using the bind construct in SystemVerilog.  Hence with proper planning one can keep the synthesizable code separate from non-synthesizable code to enable FPV.  Steps to bringing up a FPV include:  "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Compiling RTL : "/>
                    <Run Text=" "/>
                    <Run Text="The FPV tool runs on compiled and synthesizable RTL "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Creating Cover Points : "/>
                    <Run Text=" "/>
                    <Run Text="Translate each waveform diagram into an SVA sequence e.g each state of your state machine is possible. "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Creating Assumptions/Constraints: "/>
                    <Run Text=" "/>
                    <Run Text="Start with a  small set of assumptions and discover more assumptions during the debug process. "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Creating Assertions:  "/>
                    <Run Text=" "/>
                    <Run Text="Set up cover points first. "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Clocks are resets:  "/>
                    <Run Text=" "/>
                    <Run Text="SVA sequences and concurrent assertions always exist relative to some clock. Input can be a primary clock, since the FPV tool requires synthesizable code, the clock cannot be generated inside an RTL model. "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Running the verification:    "/>
                    <Run Text=" "/>
                    <Run Text="The tool will analyze the space of all possible logic executions that start in that state.  "/>
                    <Run Text=" "/>
                    <Run FontWeight="Bold" Text="Difference between a DV test and FPV tool"/>
                    <Run Text=" "/>
                    <Run Text=": A simulation tool runs on specific test vectors and validates that the current values behave as expected for each assertion and assumption in the code and checks whether they hit a cover point. An FPV tool analyzes the space of possible simulations as limited by the assumptions so that all the assertions are checked and if possible uncover a cover point or a corner case.   "/>
                    <Run Text=" "/>
                    <Run FontStyle="Italic" Text="Hence FV provides a set of powerful techniques for analyzing and verifying today's modern VLSI and SOC designs.   "/>
                    <Run Text=" "/>
                    <Run Text="Work effort from the user to setup , run and debug the FV tools includes: "/>
                    <Run Text=" "/>
                    <Run FontStyle="Italic" Text="Selecting/partitioning the design/ RTL models / Properties/ Abstractions and Tool Knobs. "/>
                    <Run FontWeight="Bold" Text="Checkers: "/>
                    <Run Text="Generalize assertions and behave as one complex assertion. "/>
                </Paragraph>
                <Paragraph>
                    <Run/>
                </Paragraph>
            </FlowDocument>
        </RichTextBox>
        <Image HorizontalAlignment="Left" Height="303" Margin="5,107,0,0" Grid.Row="1" VerticalAlignment="Top" Width="608" Source="Image2.png" Grid.ColumnSpan="3"/>
        <Label Content="SystemsC from the Ground Up, David C. Black and Jack Donovan, 2004" HorizontalAlignment="Left" Margin="7,23,0,0" RenderTransformOrigin="5.184,1.231" Width="320" Height="21" VerticalAlignment="Top" Grid.Row="2" FontSize="10"/>
        <Image HorizontalAlignment="Left" Height="238" Margin="8,405,0,0" Grid.Row="1" VerticalAlignment="Top" Width="326" Source="Image3.png"/>
        <Image HorizontalAlignment="Left" Height="194" Margin="335,405,0,0" Grid.Row="1" VerticalAlignment="Top" Width="282" Source="Image1.png" Grid.ColumnSpan="3"/>
        <RichTextBox Grid.ColumnSpan="3" HorizontalAlignment="Left" Height="155" Margin="340,564,0,0" Grid.Row="1" VerticalAlignment="Top" Width="276" Grid.RowSpan="2" TextChanged="RichTextBox_TextChanged_2">
            <FlowDocument>
                <Paragraph>
                    <Run Text="SystemC is a C++ class library built on top of ANSC C++ which allows a designer to create cycle accurate models of system level designs including SW algorithms, HW architectures and their interfaces hence converting standard C/C++ to a system descriptor language (SDL). The C++ program exhibits the same behavior as the system enabling its simulation, validation, and optimization."/>
                </Paragraph>
            </FlowDocument>
        </RichTextBox>
        <RichTextBox HorizontalAlignment="Left" Height="43" Margin="10,632,0,0" Grid.Row="1" VerticalAlignment="Top" Width="322" TextChanged="RichTextBox_TextChanged_2" Grid.RowSpan="2">
            <FlowDocument>
                <Paragraph>
                    <Run Text="Languages for system and RTL  modeling include verilog, VHDL, System Verilog, and System C"/>
                </Paragraph>
            </FlowDocument>
        </RichTextBox>

    </Grid>
</Window>
